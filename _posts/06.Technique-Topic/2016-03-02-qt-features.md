---
layout: post
title: Qt学习：moc和对象模型
categories:
- Qt
tags:
- Qt
- Library
---

> Qt基moc和对象模型提供了强大的功能：

	·信号槽机制，用于解决对象之间的通讯
	·可查询，并且可设计的对象属性；
    ·强大的事件机制以及事件过滤器；
    ·基于上下文的字符串翻译机制(国际化)，也就是使用tr()函数；
    ·复杂的定时器实现，用于在事件驱动的GUI中嵌入能够精确控制的任务集成；
    ·层次化的可查询的对象树，提供一种自然的方式管理对象关系； -- 对象模型
    ·智能指针(QPointer)，防止野指针；
    ·能够跨越库边界的动态转换机制；

---
## MOC, Meta-Object Compiler，对象元编译
### 是什么？
> Qt对标准C++的扩充，必须在标准C++编译前使用moc工具编译代码  
> 这是一种语法上的扩充，与C++的预处理不是一类事情

### 怎么用？
#### 需要moc编译的代码
- QObject的子类，并且使用Q_OBJECT宏；
#### 使用步骤：
1. 使用moc工具编译代码，生成以moc_为前缀的文件；
2. 将生成的文件添加到项目中；
3. 执行标准C++编译过程就可以了；

### 特殊说明
- 类有的时候也会定义在.cpp文件中，这个时候也可使用moc编译，但不推荐(PS:我也没弄过)
- 没有进行moc预编译，会在标准C++编译阶段报错，可以检查预编译
- moc预编译的执行过程不是递归的 -- 网上资料这么说暂未清晰明白

---
## 对象模型
### 是什么？
> Qt提供一种树结构的类对象间关系管理  

### 怎么用？
- Qt提供了祖类QObject，绝大多数Qt预定一类都是其子类
- QObject构造函数中提供了parent参数来指定其父节点
- 创建类对象时通过指定父节点对象来加入对象树

### 好处？
#### 类对象关系
- 比如窗口及其内部的组件，就可以映射为这种对象关系
- 在操作时，如事件传播，可以以此来遍历对象

#### 内存管理
- 在删除对象时会从其父节点中删除，同时也会删除其所有子节点
- 这种内存管理也可以理解：删除窗口的时候，窗口内部的组件也一起删除了

### 问题
- 对象模型是管理类对象，而继承是类之间的关系
- 涉及内存管理时，也可能存在问题：
	- 栈上先定义子对象后定义父对象，通过setParent()建立关系，退出作用域时子对象会遇到二次delete问题
	- 示例代码：{QPushButton quit("Quit"); QWidget window; quit.setParent(&window);}
