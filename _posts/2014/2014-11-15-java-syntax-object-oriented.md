---
layout: post
title: Java语法之面向对象
categories:
- Programming Language
tags:
- Java
---

> 面向对象的三个基本属性：封装、继承和多态。

## 类
- 类定义：使用关键字class定义，如class ClassName{};

### 数据成员
- 类数据成员类型可以是数据类型中的任意类型：基本数据类型、复合数据类型和类类型
- 数据成员具有默认值
	- 基本类型：数值类型初始化为0，char初始化为'\u0000',boolean初始化为false
	- 引用类型默认值为null
- 数据成员初始化
	- 在定义数据成员处进行初始化：
		- 先初始化静态数据成员，再初始化非静态数据称成员
		- 初始化按照定义的顺序进行初始化，需要注意"前向引用"问题
		- 在调用构造器之前进行自动初始化
		- 非静态实例初始化：{初始化语句}
	- 使用构造器初始化
- 静态数据成员：使用static修饰的类数据成员，也叫类数据
	- 类数据只占用一份存储空间，不管由几个类对象
	- 既可通过类名使用类数据，也可通过对象使用类数据
	- 静态数据成员的初始化：
		- 只有在使用时才会在加载类class文件时初始化静态类数据成员
		- 显示的静态初始化：static{初始化语句}

### 类方法
- 参数：
	- 基本数据类型传值，类对象传递引用
	- 可变参数，定义：void function(int arg,String...args){}
		- 可变参数args仍然是一个数组，可通过foreach来迭代
		- 可变参数参数可以为0，所以重载时通过添加必要的指定参数来避免重载失败
- 返回值：使用return返回结果
- 局部变量：
	- 局部变量没有默认值，定义时不初始化局部变量会报错
	- 局部变量不能使用static修饰
- 方法重载
	- 方法签名：由方法名＋参数列表构成
	- 重载：相同参数名，不同参数列表－－包括参数顺序、个数与类型，与返回值无关
- 构造器
	- 特点：与类同名，无返回值，可重载
	- 默认构造器：
		- 不接受任何参数的构造器叫做默认构造器，也称为无参构造器
		- 只有没有任何构造器时，编译器会自动生成一个默认构造器
	- 构造器重载与构造器中调用构造器
- finalize()和垃圾回收
	- finalize()的作用
		- finalize()不等同于C++的析构函数
		- 调用时机：垃圾回收器准备释放对象空间时先调用其finalize()方法
		- finalize()不适用于普通的清理工作：
			- 适用于"本地化"编程时释放其他语言(C++)分配的内存
		- 如果需要明确的释放资源，可自定义相关函数并明确调用
	- 垃圾回收功能
		- 对象可能不被垃圾回收
			- 垃圾回收也消耗性能，所以垃圾回收由特定的算法支持
			- 并不是对象使用完就立刻进行垃圾回收的
		- 垃圾回收并不等于"析构"
		- 垃圾回收只与内存有关

### 访问控制权限
- 类成员访问控制权限：
	- public：所有人都可以访问，一般作为接口访问权限
	- protected：同包类和所有子类都可访问，继承中不同包子类访问权限
	- 包访问权限：没有关键字则是包访问权限，同包中除private外都可访问
	- private：自由类自身才能访问，常用于单例模式
- 类访问控制权限：
	- 类访问权限决定了类是否可以被实例化为对象
	- 如果类可以实例化，则：
		- public：接口类，任何位置都可以实例化该类
		- 默认访问权限：只有同包内的其他类才可以实例化该类

### 特殊关键字
- this关键字
	- this关键字只能在发放内部使用，表示对"调用方法的那个对象"的引用
	- 常规应用：返回当前对象的引用，传递当前对象的引用
	- 特殊用法：为this添加参数列表来在构造器中调用其他构造器，位置必须在构造器最开始处
- super关键字
	- super关键字表示基类引用，可访问基类方法－－主要是在覆写方法中调用基类被覆写方法
	- super调用基类构造器：
		- 语法：super(args)
		- 位置：必须是构造器中除注释外的第一行
- static关键字
	- 类方法：使用static修饰的类方法，也叫静态方法
		- 类方法是没有this的方法
		- 既可通过类名调用类方法，也可通过对象调用类方法
		- 在类方法中不能调用非类方法，在非类方法中可以调用类方法
- final关键字
	- final关键字表示"这是无法改变的"
	- final数据
		- 基本数据类型：
			- 一旦初始化数据成员的值就不会改变
			- 使用方法初始化可是的每个类对象获得不同的非静态final数据初始值
		- 对象引用：
			- final表示的是引用关系不可变，但对象本身状态可发生变化
			- 数组也是对象,final数组标识数组名不能在引用其他数组，但数组元素引用不是final的
		- 同时用static和final修饰的，命名时全字母大写且用下划线拼接单词
		- final初始化位置：定义处或构造器中，即可定义空白final
		- final在参数中使用时，也表示不可变更引用关系，即可读属性
	- final方法
		- 主要表明方法是不可覆写的
		- 舍弃用法：用于提升效率
		- 所有private方法都包含了隐藏的final属性
	- final类
		- 表示是不可继承的类，final类内所有的数据成员和方法附带了final属性

## 继承
- 继承特性：
	- java只支持单继承关系
	- 如果没有明确的指明继承，则隐式的从Object进行继承，即所有类的祖类是Object类
- 继承：使用关键字extends指明继承关系
	- 定义语法：class ClassName extends BaseClass{}
- 初始化顺序
	- 首先，初始化static数据，从基类开始按继承顺序进行
	- 然后，对象所有数据成员都被设置为默认值(内存置零)
	- 最后，调用构造器，从基类开始按照继承顺序进行
- 清理工作
	- 除内存完全托付给垃圾回收之外，还需要定义自己的清理方法并显示调用
	- 定义清理方法，但不要使用finalize()方法
	- 在继承关系中调用清理方法的顺序与构造顺序相反：先调用导出类再调用基类
- 同名方法
	- 基类中private方法不是接口的一部分也就不存在与导出类同名问题
	- 同名不同参数：基类与导出类同名方法共同构成重载方法集合
	- 同名同参数，被称为覆写
		- 可选择添加注解@Override来明确指出是覆写而不是重载－－编译器会做检查
- 其他类之间关系：
	- 组合：在新的类中产生现有类的对象，即将对象的引用置于新类中 
		- 组合只是复用了现有程序代码的功能，而非形式
		- 组合对象的初始化包括：
			- 定义时初始化；构造器中初始化；实例初始化；
			- 使用时在初始化，也被称为惰性初始化
	- 代理,是一种组合与继承的中庸之道
		－ java没有直接提供代理语法支持，通过组合来创建被代理对象
		- 通过定义全部或部分被代理对象相同的接口来实现继承中的接口继承
- 组合与继承的选择
	- 组合与继承是java代码复用的两种方式
	- 组合：
		－ 使用的现有程序代码的功能，但新类可提供自己的接口
	- 继承：
		- 复用了现有程序代码的功能的同时也继承了基类的接口
		- 继承还代表了基类与新类之间的类型关系
	- 选择：
		- 组合比继承更常用一些
		- 如果明确需要向上转型，则说明继承是更好的选择


## 多态
- 多态的作用，是消除类型之间的耦合关系
	- 继承中基类与导出类之间是通用类与特殊类的关系
	- 创建处理基类类型对象的方法更加通用，因为可使用适用于该基类的所有导出类
	- 多态使程序代码具有可扩展性
		- 继承基类的导出类可以不用修改的就融入到现有的继承体系中
	- 多态是一项让程序员"将改变的事物与未改变的事物分离开来"的重要技术
- 动态绑定(后期绑定)，是在运行时根据对象的类型进行绑定
	- 语言支持动态绑定，则会在运行时有方法确定对象的类型－－即类型信息
	- 相对应的时前期绑定，在程序执行前进行绑定，即编译器知道接受方法调用的对象
	- 除static方法和final方法(private方法属于final方法)外，其他所有方法都是后期绑定
- 注意事项：
	- 多态，只是针对继承关系中的普通方法的
	- 导出类中与基类private方法相同签名的方法，以调用对象的定义类型为准
	- 构造器中的多态问题：
		- 基类构造器中调用的方法被导出类覆写
		- 创建导出类时调用基类构造器，则基类构造器中调用的是导出类中覆写后的方法
		- 因为导出类对象还没有创建完成，所以该行为具有不确定性
		- 建议：用尽可能简单的方法使对象进入正常状态，可能的话，避免调用其他方法
		- 实践：将构造与初始化分开，定义专门的初始化函数(如定义init()方法)并明确调用

## 特殊类	
### 抽象类
- 抽象方法：仅声明而没有方法体
	- 语法：abstract void functionName();
- 抽象类：包含一个或多个抽象方法的类，必须被限定为抽象类
	- 语法：abstract class ClassName{}
	- 抽象类的一个主要特征：
		- 不能实例化，抽象类主要提供一种接口和部分功能实现
		- 没有实现所有抽象方法的导出类也必须被限定为抽象类
	- 也可以定义不包含抽象方法的抽象类－－仅仅阻止类的实例化

### 接口
- 接口定义：
	- 使用interface代替class，如interface InterfaceName{}
	- 访问权限：public和包访问权限
- 实现接口：一个类可以实现多个接口
	- 语法：class ClassName implements InterfaceName1,InterfaceName2{}
- 接口成员：
	- 接口中的数据成员和方法的权限都是public的
	- 接口中定义的数据成员：
		- 隐式地是static和final的，并且是public的
		- 不能定义空final数据成员
- 接口继承
	- 接口继承使用关键字extends，并且接口支持多继承
	- 多重继承中的名字冲突：重载和覆盖是没有问题的，但是仅返回值不同则会编译报错
- 接口嵌套
	- 接口嵌套，即在接口或类中定义接口
	- private修饰的嵌套接口仅定义类可实现该接口
- 接口作用：
	- 继承体系是对事物之间'is-a'的关系的抽象，一个继承体系同时也是封闭的
	- 接口是对象行为特性，不同继承体系中的对象可具有先同的行为特性，所以接口可扩展继承体系

### 内部类
－ 内部类分类：
	- 按定义位置分为：类内部类(类内部定义)，局部内部类(方法或局部作用域中定义)
	- 按照内部类的定义又可以分为：
		- 普通内部类
		- 匿名内部类：没有类名称的内部类
		- 嵌套内部类：使用static修饰的内部类
－ 内部类的特性：
	- 除嵌套内部类外，内部类可以访问外部类的所有成员(不受访问修饰符限制)
	- 内部类与外部类之间建立了关联
- 类的普通内部类
	- 类型声明：OuterClassName.InnerClassName
	- 创建对象：outerClassObjectName.new InnerClassName();
	- 外部类引用：OuterClassName.this
	- 要求：创建内部类对象，需要先创建外部类对象
- 匿名内部类
	- 匿名类一般定义在方法中，作为返回值使用
	- 定义：new Super(args){}
	- 特性：
		- 只能继承一个类或实现一个接口
		- 匿名类没有构造器，可使用实例初始化语法代替
		- 定义的同时也创建匿名类实例，并通过匿名类的基类或实现接口来引用该对象
		- 匿名对象使用的外部对象引用必须是final的
	- 多层内部类(内部类中定义内部类)，所有内部类中可透明访问所有的外围类的成员
	- 限制：
		- 普通内部类不能定义static数据和static方法，但是可定义常量
		- 原因可理解为：
			- 内部类可看作外部类的非静态成员，所以加载顺序是在外部类创建之后加载内部类
			- 内部类中的静态变量则需要：加载外部类、加载内部类、初始化静态变量
			- 从上面的顺序中看到，内部类的加载顺序存在冲突，所以编译器会以错误处理
- 嵌套内部类
	- 声明为static的内部类
	- 普通内部类不能包含static数据和定义嵌套内部类，嵌套内部类无此限制
	- 嵌套类没有外部类的引用，所以：
		- 可以不需要外部类对象就可以创建嵌套类对象
		- 不可以从嵌套类内部访问非静态的外围类对象
	- 嵌套类的一个应用是为接口些测试代码：
		- 在接口中定义实现该接口的测试类
- 内部类的作用
	- 根据类的封装特性，内部类可以实现代码细节的隐藏
	- 根据内部类与外部类的关联：
		- 内部类是外部类的另一个接口
		- 实现闭包和回调
	- 匿名类在gui和框架中有很多应用
- 内部类的继承
		- 继承说明中需要指明外部类，即OuterClassName.InnerClassName
		- 构造器参数，需要传递外部类对象
		- 构造器中需要调用super(outerClassObjectName)
- 内部类的覆写
	- 内部类是独立的实体，所以外围类的继承中基类和导出类定义的同名内部类是不冲突的 
